---
layout: post
title: "[CS] Network - 기본 개념"
# date: 2021-12-10 12:34:43 +0900
categories: CS
---

### 프로토콜 유형

- 연결 지향 프로토콜
  - 각각의 패킷은 서로 독립적으로 처리 됨.
  - 하나의 메시지가 패킷으로 나누어 목적지로 전달될 때, 각각의
  - 패킷은 동일 경로, 혹은 다른 경로를 통해 전달 될 수 있다.
- 비연결 프로톨
  - 하나의 메시지에 속하는 모든 패킷은 서로 연관이 있음.
  - 메시지의 데이터그램을 보내기 전에, 데이터그램 경로를 위한 가상 연결 경로를 설정해야 함
  - 연결 설정 이후, 데이터그램은 동일 경로로 전달
  - 이런 유형의 서비스에서는, 패킷은 소스와 목적지 주소뿐만 아니라, 패킷이 흐르는 가상 회선을 정의하는 가상 회선 식별자인 흐름 레이블이 필요함

### OSI 7계층

1. Physical layer: 물리적 특성을 이용해 통신 케이블로 데이터를 전

   - 단위: bit
   - 장비: 케이블, 리피터, 허브

2. Data Link layer: MAC address 기반으로 물리적 연결 과정에서 생기는 오류 검출, 흐름 제어 등을 수행.

   - 단위: frame (ex: 이더넷)
   - 장비 : 스위치
   - 인접 시스템간 신뢰성 있는 연결 보장.

3. Network layer: 논리적 주소인 IP address를 담당하며, 패킷의 전달 경로를 결정.

   - 단위: Packet (ex: Router)
   - 장비 : 라우터
   - 어드래싱, 라우팅, 포워딩
   - 패킷 스위칭
     - 데이터그램 방식(비연결형), 가상회선 방식(연결 지향형)

4. Transport layer: End to End간 메시지 전송에서 오류 검출과 흐름 제어를 담당.

   - 단위: Segment (ex: TCP, UDP)
   - 종단 시스템 간 신뢰성 있는 전송 보장(연결제어, 오류검출, 흐름제어)

5. Session layer: 양쪽 Host 간 연결을 수립/유지/종료시키는 역할
6. Presentation layer: 코드 간의 번역(인코딩, 디코딩)을 담당.
7. Application layer: 사용자에게 통신을 위한 서비스 제공. 인터페이스 역할.
   - HTTP, SNMP 등 네트워크 서비스 제공.

### TCP/IP 프로토콜

![image](https://user-images.githubusercontent.com/28949166/147556151-f125519b-5a2b-4983-8f7d-ec2f061a44a5.png)

- OSI 7계층 중 5~7계층을 하나로 묶어서 사용.
- 사실상 구성 계층은
  5~7계층(응용계층)
  4계층(전송계층)
  3계층(네트워크 계층)1~2계층(물리 계층. 이하 네트워크 접속 계층이라 칭함.)
- OSI 7계층과의 차이점
  ![image](https://user-images.githubusercontent.com/28949166/147554673-5a45b811-2152-4c02-b92c-e58f3d7a160a.png)

  #### TCP 특징

  - 점대점 : 두 노드간의 통신
  - 전이중 : 양방향 통신이 가능
  - 흐름제어 : 수신측의 처리량을 고려하여 데이터를 전송
  - 혼잡제어 : 특정 네트워크 구간에 데이터가 몰리지 않도록 처리

  #### 3 way hand shaking

  > TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish) 하는 과정

        1. Client -> Server : SYN
        2. Server -> Client : syn+ack
        3. Client -> Server : Ack

  #### 4 way hand shaking

  > TCP의 연결을 해제(Connection Termination) 하는 과정

        1. Client -> Server : FIN
        2. Server -> Client : ACK
        3. Server -> Client : FIN
        4. Client -> Server : ACK

  #### TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유?

  - Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.
  - 연결할 때는 ACK 과 SYN을 함께 보낸다.

  #### TCP 연결 끊김 탐지

  - timeout : 일정한 시간 동안 상대방으로부터 메시지(ex. FIN)가 오지 않으면 연결 종료.
  - keep alive : 주기적으로 상대방에게 메시지를 보내 응답이 오는지 확인함으로써 상대 호스트 연결이 유지되고 있는지 확인.

  #### TCP vs UDP

  ![image](https://user-images.githubusercontent.com/28949166/147557360-897c4b2c-618a-4423-94b2-2b58d52e62c7.png)

  #### 주소

  > 통신은 호스트의 프로세스 간에 이루어진다.

  - 물리 주소(MAC 주소) : 네트워크 안에서 장치를 구분하기 위한 표식. 유니크한 값이다. 장치가 공장에서 생산도리 때 부여되는 주소.
  - IP 주소 : 네트워크 주소+호스트 주소. 네트워크 안에서 호스트를 구분하기 위한 표식. 하나의 컴퓨터는 여러 개의 IP 주소를 가질 수 있다.(네트워크마다) 인터넷 망에 접속할 때마다 주소가 달라진다.
    > 115.145.241.68
  - 포트 번호 : 16비트. 호스트 상에서 프로세스를 구분하기 위한 표식(어느 프로세서로부터 데이터가 왔는지를 구분)
  - 통신 절차
    > 1. TCP헤더에 송신자포트와 수신자포트 정보를 추가 (패킷 생성)
    > 2. 해당 패킷을 서버로 전달
    > 3. 서버는 이 패킷을 받아 헤더 안의 수신자포트를 확인(사용자가 무엇을 원하는지 확인)
    > 4. 포트번호가 1000번일 경우, 1000번 포트에 해당하는 프로세스로 연결한다.

  #### IPv6

  - IPv4의 한계
    - 32비트로 구성, .으로 각 필드를 구분.
    - 산술적으로 주소를 43억 개 할당 가능하지만, 클래스 별 주소 분류 방식(NT를 표현하는 prefix를 고정, host를 표현하는 subfix는 가변적인 방식) 때문에 사용하지 않는 주소가 더 많다.
    - IoT 환경에서는 각각의 단말기 마다 IP가 부여되는 환경이 필요하므로 기존 IPv4를 사용하면 IP 주소가 부족할 것이다.
  - IPv6

    - 128비트(16바이트)로 구성.
    - 고정길이 헤더.
    - 16진수 32개로 표현하며, 16진수 4개마다 콜론으로 구분한다.

    ### IPv4 주소 고갈 문제 해결 방안

    - 모든 디바이스가 IPv6를 지원하는 것은 아니므로 IPv4를 효율적으로 활용할 방안도 필요하다.

    #### NAT

    - 사설 주소와 공인 주소의 매핑을 제공
    - 사설 주소를 이용해 내부 통신.
    - 인터넷의 컴퓨터와 통신을 할 때 공인주소를 통해 외부 통신을 가능하게함.

  #### 서브네팅

  - 관리자가 관리하기 편하도록 네트워크를 쪼개는 것.
  - 하나의 네트워크 IP를 여러개의 다수 네트워크 IP로 분할하는 작업.

---

### 전송계층의 데이터 전달 프로토콜

1. stop and wait 프로토콜
   - 한번에 데이터 하나 보낼 때마다 ack 올 때까지 기다렸다가 다음 데이터 보냄.
   - 송, 수신자 슬라이딩 윈도우 크기 1
   - 각 패킷에 체크섬 추가
   - 체크섬 검사 후 오류 있으면 통보 없이 버림.
   - ack 유실시 중복 수신 될 수도 있음.
2. go-back -n 프로토콜
   - 한꺼번에 여러 개 보낼 수 있음. (seqNo, ackNo)
   - 송신 윈도우 여러개, 수신 윈도우 크기 1 (들어올 때마다 상위로 보냄)
   - 송신 윈도우 크기는 2^m 미만이어야 잘 동작. 이상이면 오류 (m = 윈도우 비트 수)
   - 데이터는 유실되지 않았는데 ack만 유실되어 건너 뛰어서 ack가 오면, 잘 수신했는데 ack 유실된 것으로 보고 무시하고 그냥 다음꺼 계속 보냄
   - 데이터 패킷 유실된 경우, 다음꺼로 온거 버리고 계속 유실된거 보내라고 ack 보냄. 타임아웃 된 뒤 재전송. = 순서에 안맞는 데이터는 버림.
3. selective repeat 프로토콜
   - selective repeat 프로토콜은 순서에 맞지 않게 오더라도 이를 버리지 않고 뒀다가 빠진 데이터가 들어오면 그것과 함께 처리하는 방식으로 계산됨
   - 송수신 슬라이딩 윈도우 여러개
   - 2^m-1보다 작은값으로 윈도우 사이즈를 유지하면 오류가 없이 작동 가능.
   - selective-repeat 프로토콜은 버리지 않고 버퍼에 모아뒀다가 빠진게 들어오면, 합해서 상위계층에 올림.
   - 하나하나마다 ack를 줌. ackNo는 잘 받은 패킷의 번호
4. bidirectional 프로토콜
   - 양방향 프로토콜. ack를 데이터 안에 보냄 = 피기백킹

---

### HTTP 프로토콜

#### HTTP 프로토콜

- HTTP(Hyper Text Transfer Protocal)이란 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜입니다. HTTP는 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동합니다. HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이며 Method, Path, Version, Headers, Body 등으로 구성됩니다.

#### HTTP vs HTTPS

- HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 비밀번호나 주민번호 등을 주고 받으면 제3자에 의해 조회될 수 있습니다. 이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다. HTTPS는 자신의 공개키를 갖는 인증서를 발급하여 보내는 메세지를 공개키로 암호화하도록 하고 있습니다. 공개키로 암호화된 메세지는 개인키를 가지고 있어야만 복호화가 가능하기 때문에, 기업을 제외한 누구도 원본 데이터를 얻을 수 없습니다.

---

### 질문 모음

#### SYN Flooding 공격, 방어 방법

- client가 server로 연결 요청(SYN)을 보내면 server가 백로그 큐에 저장하는데, 큐가 가득 차게 되면 더 이상 요청을 받을 수 없게 된다. Denial of Service(Dos) attack 중 하나이다.

- 해결방법
  1. Cookie 사용: 서버가 SYN+ACK 메시지를 보낼 때 SYN Cookie도 함께 보낸다. 일정 시간 동안 해당 쿠키에 대한 응답 패킷이 오지 않는다면 방화벽에서 차단한다.
  2. 타임아웃 시간을 짧게 잡아 백로그 큐를 계속해서 비워줄 수 있다.

#### 로드 밸런싱

- 둘 혹은 셋이상의 중앙처리장치 혹은 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것을 의미한다. 이로써 가용성 및 응답시간을 최적화 시킬 수 있다.

#### 싱글스레드 서버와 멀티스레드 서버 예시

- 참고 자료 : [싱글스레드(Single thread) vs 멀티스레드 (Multi thread)](https://velog.io/@gil0127/%EC%8B%B1%EA%B8%80%EC%8A%A4%EB%A0%88%EB%93%9CSingle-thread-vs-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-Multi-thread-t5gv4udj)

- 스레드 : 프로세스가 할당받은 자원을 이용하는 실행의 단위

- 멀티 스레드 서버

  - 대부분의 웹어플리케이션이 사용하는 방식.
  - 여러 사용자의 request와 response 처리

    ![image](https://user-images.githubusercontent.com/28949166/147561676-e21417b6-0f4c-4848-8e5a-b063fb9ea228.png)

  >

        (1) 웹 서버는 내부적으로 스레드 풀을 유지
        (2) 클라이언트는 서버에 요청을 전달
        (3) 스레드 풀 내의 각각의 스레드가 blocking I/O 등의 클라이언트 요청을 처리하고 응답

  ![image](https://user-images.githubusercontent.com/28949166/147562760-436b1c53-be8d-4ac6-b526-958e755d82d3.png)

  - 장점
    - 응답성 : 프로그램의 일부분(스레드 중 하나)이 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이 계속 되어 사용자에 대한 응답성이 증가한다. 다시 말해서, 멀티 스레드 모델은 에러 발생 시 새로운 스레드를 생성하여 극복한다. 다만, 새로운 스레드 생성이나 놀고 있는 스레드 처리에 비용이 발생한다.
    - 경제성 : 프로세스 내 자원들과 메모리를 공유하기 때문에 메모리 공간과 시스템 자원 소모가 줄어든다. 스레드 간 통신이 필요한 경우에도 쉽게 데이터를 주고 받을 수 있으며, 프로세스의 context switching과 달리 스레드 간의 context switching은 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.
  - 단점
    - 여러 스레드가 자원을 공유하고 있기 때문에 같은 자원에 접근하거나 해당 자원에 대해 작업을 실행하려는 경우 에러가 발생하거나 원하는 값이 나오지 않는 것을 방지하기 위해서 스레드를 동시에 같은 자원이 접근하지 못하도록 제어해줘야한다.
    - 스레드 수만큼 자원을 많이 사용

- 싱글 스레드 서버

  ![image](https://user-images.githubusercontent.com/28949166/147561703-ff2b4f1a-3002-4c51-ac6f-c9579a26eb21.png)

  >

        (1) 서버 내부에 단일 스레드가 무한 루프를 돌며 클라이언트의 요청을 대기(이벤트 루프 구조)
        (2) 클라이언트는 서버에 요청을 전달
        (3) 서버는 복잡한 작업이나 Blocking I/O 등의 처리는 스레드 풀의 스레드에 작업을 넘기고 다음 클라이언트의 요청을 받음
        (4) Blocking I/O 등의 작업을 요청받은 스레드는 작업을 수행 후 callback function을 통해 이벤트 루프 내 단일 스레드에 응답
        (5) 이벤트 루프 내 단일 스레드는 해당 클라이언트에 응답을 전달

  ![image](https://user-images.githubusercontent.com/28949166/147562800-490dc0a6-abe0-480b-a30d-b7ce4bea8b10.png)

  - 장점 :
    - 여러개의ㅏ 스레드가 프로세스의 자원을 공유하지 않아 자원의 접근에 대한 동기화를 신경쓰지 않아도 된다.
    - CPU 메모리를 적게 사용
  - 단점 :
    - 싱글 스레드 모델은 에러 처리를 못하는 경우 멈춘다.

#### 흐름제어 방식의 원리와 대표적인 방식

- 흐름제어란 종단 시스템간 통신에서 패킷의 흐름(속도)을 제어하는 것을 의미한다.

1. Stop and wait 방식
   - 매번 전송한 패킷에 대한 응답을 받아야 다음 패킷을 보내주는 방식.
2. Sliding window 방식
   - 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하여 제어하는 기법이다.

#### DNS

- 도메인 이름과 IP 주소 값을 매핑시켜줌.
- 목적지 주소가 www.snut.ac.kr과 같이 도메인 이름을 입력한 경우에는, DNS 서버에게 질의하여, 도메인 이름에 해당하는 IP 주소 값을 먼저 해결해야 함

#### VLAN

- Virtual Local Area Network 의 약자로 물리적 배치와 상관없이 논리적으로 LAN을 구성할 수 있는 기술
- 장점
  - 네트워크 리소스 보안을 높인다. 네트워크 그룹 설정을 변경하거나 이동하게 되면 보안상의 문제가 발생할 우려가 있지만 VLAN을 이용하면 실제적인 네트워크 그룹의 이동이 없어도 되어 보안상의 문제를 쉽게 줄일 수 있다.
  - 기존 토폴로지의 큰 물리적 변화가 없어도 네트워크 구조를 변경할 수 있음.

#### ARP

- IP를 알고있는데, MAC주소를 모를 때 맥주소를 해결하는 프로토콜
- ARP 요청 : 브로드캐스팅함(모든 컴퓨터들이 이 메시지를 수신해서 그 안에 정보를 보고 자신을 찾는 메세지면 응답)
- ARP 응답 : 유니캐스트(정확하게 목적지 하나, 자신을 찾는 컴퓨터에게 보냄)
- 통신 순서
  >
        요청 브로드캐스트
        -> 브로드캐스트 요청이 나를 찾는건지 확인
        -> 나를 찾는거면 응답패킷 전송
        -> 송신 스테이션은 응답 패킷을 받으면 목적지 맥주소를 알게되고 이를 알게 되면 arp 캐시에 이 맥주소를 저장해두고 일정기간동안 사용
        -> 사용하지 않는 시간이길어지면(스테이션이 이동할수도 잇기 때문에) 타임아웃되어 해당 정보를 무효화시키고 다시 주소를 찾아서 사용.

#### ARQ

- 재전송 기반 에러제어

1. Stop and Wait
2. Go Back N

#### HTTP method

- GET : 데이터 조회
- POST : 데이터 추가
- PUT : 데이터 갱신
- DELETE : 데이터 삭제

#### REST

- 참고 자료 : [REST란? REST API란? RESTful이란?](https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html)
- REST(Representational State Transfer)
  - 효율적, 안정적이며 확장가능한 분산시스템을 가져올 수 있는소프트웨어 아키텍처 디자인 제약의 모음을 나타냅니다. 그리고 그 제약들을 준수했을 때 그 시스템은 RESTful하다고 일컬어진다.
  - HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미
  - 즉, REST는 자원 기반의 구조(ROA, Resource Oriented Architecture) 설계의 중심에 Resource가 있고 HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍쳐를 의미한다.
- 장점
  - HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
  - REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다
- 단점
  - 구형 브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다.(PUT, DELETE를 사용하지 못하는 점)
- REST 구성요소
  1. 자원(Resource): URI
     - 모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.
     - 자원을 구별하는 ID는 ‘/groups/:group_id’와 같은 HTTP URI 다.
     - Client는 URI를 이용해서 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 Server에 요청한다.
  2. 행위(Verb): HTTP Method
     - HTTP 프로토콜의 Method를 사용한다.
  3. 표현(Representation of Resource)
     - Client가 자원의 상태(정보)에 대한 조작을 요청하면 Server는 이에 적절한 응답(Representation)을 보낸다.
     - REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태의 Representation으로 나타내어 질 수 있다.
- REST 특징
  - 서버-클라이언트 구조
  - 무상태 : Server는 각각의 요청을 완전히 별개의 것으로 인식하고 처리한다
  - 인터페이싀 일관성 : 특정 언어나 기술에 종속되지 않는다.
- REST API 설계 규칙

  - 슬래쉬(/)는 계층 관계를 나타내는 데 사용한다.
  - URI 마지막 문자로 슬래시(/ )를 포함하지 않는다.
  - 언더바(\_)는 URI에 사용하지 않는다.
  - URI 경로에는 소문자가 적합하다.

- REST 응답 상태 코드

  - 1xx : 전송 프로토콜 수준의 정보 교환
  - 2xx : 클라어인트 요청이 성공적으로 수행됨
  - 3xx : 클라이언트는 요청을 완료하기 위해 추가적인 행동을 취해야 함
  - 4xx : 클라이언트의 잘못된 요청
  - 5xx : 서버쪽 오류로 인한 상태코드

- RESTful
  - RESTful은 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다.
    - RESTful 하지 못한 경우
      >
            Ex1) CRUD 기능을 모두 POST로만 처리하는 API
            Ex2) route에 resource, id 외의 정보가 들어가는 경우(/students/updateName)

#### CORS

- Cross Origin Resource Sharing이라고 하는데, 클라이언트에서 다른 domain의 서버에 요청을 보내는 기술이다. 해당 domain의 서버의 응답헤더와 클라이언트의 요청헤더 모두 CORS를 허용한다는 옵션을 가지고 있어야 한다.

#### DHCP

- 주소의 할당을 사람이 일일이 수동으로 하는 것이 아니라, 컴퓨터가 켜지면 자동으로 주소를 받아와 쓸 수 있게끔 하는 것. TCP/IP의 네트워크 계층을 도와준다.

#### HTTP 버전

- HTTP 1.1 : 커넥션 타임아웃(persistant connection), 파이프라이닝 기법으로 요청 처리.
- HTTP 2.0 : 멀티플렉싱(양방향 전송가능, 한 커넥션에 여러개 메시지를 주고받을 수 있음), Sever push, 헤더 압축
- HTTP 3.0 : 구글이 만들었고, TCP가 아닌 UDP를 사용함. 통신되는 데이터마다 독립된 스트림을 가짐.

#### 프록시 서버의 기능

- 프록시 서버 : 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해 주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.
- 프록시 서버 중 일부는 프록시 서버에 요청된 내용들을 캐시를 이용하여 저장해 둔다. 이렇게 캐시를 해 두고 난 후에, 캐시 안에 있는 정보를 요구하는 요청에 대해서는 원격 서버에 접속하여 데이터를 가져올 필요가 없게 됨으로써 전송 시간을 절약할 수 있게 됨과 동시에 불필요하게 외부와의 연결을 하지 않아도 된다는 장점을 갖게 된다. 또한 외부와의 트래픽을 줄이게 됨으로써 네트워크 병목 현상을 방지하는 효과도 얻을 수 있게 된다.

#### unicast, multicast, broadcast 설명

- 유니캐스트 : 정보를 전송하기 위한 프레임에 자신의 MAC 주소와 목적지의 MAC 주소를 첨부하여 전송하는 방식. 1 대 1 통신
- 멀티캐스트 : 네트워크에 연결되어 있는 시스템 중 일부에게만 정보를 전송하는 것으로 특정 그룹에 속해 있는 시스템에게만 한 번에 정보를 전송할 수 있는 방법을 말한다. 멀티캐스트는 라우터가 멀티캐스트를 지원해야만 사용 가능하다는 단점이 있다. 1 대 다 통신.
- 브로드캐스트 : 멀티캐스트 그룹 단위로 묶어 그 그룹의 Host 들은 동시에 데이터를 받을 수 있다. 다 대 다 통신.

#### 웹 소켓 설명

- 웹 소켓 등장 이전 : 웹소켓이 나오기 이전에는 모두 클라이언트의 요청이 없다면, 서버로부터 응답을 받을 수 없는 구조였습니다.

![image](https://user-images.githubusercontent.com/28949166/147565127-5cf6825e-9ce0-4b34-b0a5-88fcf7997076.png)

- 웹 소켓 : HTML5에서 등장. Transport protocol의 일종으로 서버와 클라이언트 간의 효율적인 양방향 통신을 실현하기 위한 구조. 웹소켓을 이용하면 하나의 HTTP 접속으로 서버와 브라우저 사이에 양방향 소통이 가능.

- 필요성 : 기존에는 서버와 클라이언트가 실시간으로 상호작용하는 웹 서비스를 개발하기 위해서 숨겨진 프레임을 이용하는 방법이나 Long Polling, Stream 등과 같은 다양한 방법을 사용했었습니다. 하지만 이 방식은 브라우저가 HTTP 요청을 보내고 웹 서버가 이 요청에 대한 HTTP 응답을 보내는 단방향의 메시지 교환 방식을 유지하는 선에서 구현된 방식입니다. 즉, 기존의 방법에 일종의 트릭을 사용한 방법입니다. 이 때문에 기존의 웹 기술을 이용하여 실시간 웹 서비스를 만드는 일은 복잡하고 어려웠습니다.

- 단점

  - 웹 소켓은 HTTP와 달리 Stateful protocol이기 때문에 서버와 클라이언트 간의 연결을 항상 유지해야 하며 만약 비정상적으로 연결이 끊어졌을때 적절하게 대응해야 한다. 이는 기존의 HTTP 사용시와 비교했을때 코딩의 복잡성을 가중시키는 요인이 될 수 있습니다.
  - 서버와 클라이언트 간의 Socket 연결을 유지하는 것 자체가 비용이 듭니다.
    특히나 트래픽 양이 많은 서버같은 경우에는 CPU에 큰 부담이 될 수 있습니다.
  - 오래된 버전의 웹 브라우저에서는 지원하지 않습니다. (물론 SockJS 라이브러리 같은 경우에는 Fallback option을 제공하고 있습니다.)
  - 브라우저별로 지원하는 웹소켓 버전이 다르며 오래된 브라우저의 경우 아예 지원하지 않습니다. 따라서 자바스크립트를 이용하여 브라우저에 상관없이 실시간 웹을 구현할 수 있는 Socket.io를 좀 더 많이 사용하고 있습니다.

- 사용 예시 : SNS 앱, 화상채팅 앱, 구글 Doc 같이 여러 명이 동시 접속해서 수정할 수 있는 Tool

#### XSS

![image](https://user-images.githubusercontent.com/28949166/147565686-7799397c-c42f-4f6e-ad43-fec8492c1a1e.png)
![image](https://user-images.githubusercontent.com/28949166/147565698-d7f27d27-d40a-4722-8009-f61b4ca5cbb1.png)

- XSS(Cross-Site Scripting) : 웹 애플리케이션에서 일어나는 취약점으로 관리자가 아닌 권한이 없는 사용자가 웹 사이트에 스크립트를 삽입하는 공격 기법.

- 대응 방안
  - 스크립트 문자 필터링 : 모든 입력값에 대해 서버측에서 필터링을 해주어야한다.
  - 웹 방화벽 사용

#### Big endian, Little endian 설명

- Big endian
  ![image](https://user-images.githubusercontent.com/28949166/147566089-13e80b9d-ad1f-412f-af9b-c7861638c466.png)
  ![image](https://user-images.githubusercontent.com/28949166/147566043-2afba148-39a6-4789-847c-c032d1e59d3c.png)

- Little endian
  ![image](https://user-images.githubusercontent.com/28949166/147566062-d634c595-b540-4a32-ac66-6c1c4f80560c.png)
  - Big endian의 반대

#### sliding window

![image](https://user-images.githubusercontent.com/28949166/147566269-6ca4e8f7-ce83-44b3-a1a6-5e814a052693.png)

- 슬라이딩 윈도우
  - 고정 사이즈의 윈도우가 이동하면서 윈도우 내에 있는 데이터를 이용해 문제를 풀이하는 알고리즘.
  - 윈도우에 포함되는 모든 패킷을 전송하고, 전송이 확인되는 대로 윈도우를 옆으로 옮겨(slide) 다음 패킷들을 전송하는 방식

#### 이더넷 설명

- 이더넷
  - LAN에서 가장 많이 활용되는 기술 규격.
  - 이더넷은 OSI 모델의 물리 계층에서 신호와 배선, 데이터 링크 계층에서 MAC(media access control) 패킷과 프로토콜의 형식을 정의한다
  - 이더넷은 네트워크에 연결된 각 기기들이 48비트 길이의 고유의 MAC 주소를 가지고 이 주소를 이용해 상호간에 데이터를 주고 받을 수 있도록 만들어졌다.

#### ATM이란?

- ATM(Asynchronous Transfer Mode)
  - 비동기 전달모드

#### 패킷교환/회선교환 설명

- 패킷 스위칭
  - 데이터를 패킷이라는 단위로 분할하여 전송(ex) IP)
  - 라우팅 알고리즘을 이용해 경로를 설정.
  - 접근 방법 : 연결(가상회선 방식), 비연결(데이터그램 방식)
- 서킷 스위칭
  - 통신 이전에 통신하는 두 장비 간 서킷이라는 연결을 만들어 통신에 사용
  - 속도와 성능이 일정함.
  - 노드간의 물리적 링크가 연속적으로 연결.
  - 회선 독점이기 떄문에 중간에 난입 불가.
  - 회선 분할 방식 : FDM(주파수를 쪼개서 공유, 시간은 고정), TDM(주파수를 시간 단위로 분할하여 공유하는 방식, 주파수는 고정)

#### 스위치와 라우터 차이

- 스위치는 2계층, 라우터는 3계층 장비이다. 스위치는 MAC 주소를 기반으로 통신 노드와 노드 사이의 경로를 지정한다.
- 라우터는 IP 주소를 기반으로 목적지 호스트까지의 최단 경로를 결정한다.

---

### 참고 자료

- [기술면접 대비 CS 질문 모음](https://kjsu0209.github.io/Tech-Interview/network/network)
- [CS 기술면접 질문 - 네트워크 (4/8)](https://mangkyu.tistory.com/91?category=761303)
